-- full graph
TP(Sym(3),OrderingGT(Sym(2),Const(5)))
TP(Sym(4),NumericPlus(Sym(2),Sym(1)))
TP(Sym(5),SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(3),Block(Sym(4)))))
TP(Sym(6),SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(5)))))
TP(Sym(7),ArrayLength(Sym(6)))
TP(Sym(9),ArrayIndex(Sym(6),Sym(8)))
TP(Sym(10),NumericPlus(Sym(9),Const(2)))
TP(Sym(11),SimpleLoop(Sym(7),Sym(8),ArrayElem(Block(Sym(10)))))
TP(Sym(12),ArrayIndex(Sym(6),Const(0)))
TP(Sym(13),Reflect(Print(Sym(12)),Summary(true,true,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(14),ArrayIndex(Sym(11),Const(0)))
TP(Sym(15),Reflect(Print(Sym(14)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(13))))
TP(Sym(16),Reify(Sym(15),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(13), Sym(15))))

-- before transformation
var x6 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x5 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
if (x3) x5 += x4
}
x6 ++= x5
}
val x12 = x6.apply(0)
val x13 = println(x12)
val x7 = x6.length
var x11 = new Array[Int](x7)
for (x8 <- 0 until x7) {
val x9 = x6.apply(x8)
val x10 = x9 + 2
x11(x8) = x10
}
val x14 = x11.apply(0)
val x15 = println(x14)

-- vertical transformation

(VFT) No producers found for TP(Sym(6),SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(5)))))

(VFT) No producers found for TP(Sym(5),SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(3),Block(Sym(4)))))

(VFT) Fusing consumer TP(Sym(11),SimpleLoop(Sym(7),Sym(8),ArrayElem(Block(Sym(10))))) with real producer: Sym(6)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(5).
(VFT) MultiCollect+Any fusion: fuse consumer with inner array of producer.
(VFT) General fusion: remap index to Sym(2), SimpleIndex to Sym(4).
(VFT) SimpleCollectIf+SimpleCollect fusion: use producer loop with consumer body.

(VFT) all vertically fused: List(Sym(6), Sym(19))

-- after vertical transformation
var x6 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x5 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
if (x3) x5 += x4
}
x6 ++= x5
}
val x12 = x6.apply(0)
val x13 = println(x12)
var x19 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x18 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
val x17 = x4 + 2
if (x3) x18 += x17
}
x19 ++= x18
}
val x20 = x19.apply(0)
val x21 = println(x20)

-- horizontal transformation
(HFT) Recording Sym(6), no fusion
(HFT) Recording Sym(5), no fusion
(HFT) Fusing Sym(19) with containing fusion set FusedSet(shape = Const(30), indexSym = Sym(1), loopSyms = List(Sym(6), Sym(19)))
(HFT) - already using same index Sym(1)
(HFT) Recording Sym(18), no fusion

(HFT) all horizontally fused: List(Sym(6), Sym(19))

-- after horizontal transformation
var x6 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x5 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
if (x3) x5 += x4
}
x6 ++= x5
}
val x12 = x6.apply(0)
val x13 = println(x12)
var x19 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x18 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
val x17 = x4 + 2
if (x3) x18 += x17
}
x19 ++= x18
}
val x20 = x19.apply(0)
val x21 = println(x20)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(6)),List(SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(5))))),SimpleFatLoop(Const(30),Sym(1),List(FlattenElem(Block(Sym(5))))))
TTP(List(Sym(19)),List(SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(18))))),SimpleFatLoop(Const(30),Sym(1),List(FlattenElem(Block(Sym(18))))))

var x6 = new ArrayBuilder[Int]
var x19 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
var x5 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
if (x3) x5 += x4
}
var x18 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + x1
val x17 = x4 + 2
if (x3) x18 += x17
}
x6 ++= x5
x19 ++= x18
}
val x12 = x6.apply(0)
val x13 = println(x12)
val x20 = x19.apply(0)
val x21 = println(x20)
-- done
