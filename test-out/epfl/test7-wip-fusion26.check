-- full graph
TP(Sym(2),NumericPlus(Const(1),Sym(1)))
TP(Sym(3),OrderingGT(Sym(2),Const(5)))
TP(Sym(4),SimpleLoop(Const(10),Sym(1),ArrayIfElem(Sym(3),Block(Sym(2)))))
TP(Sym(5),ArrayLength(Sym(4)))
TP(Sym(7),ArrayIndex(Sym(4),Sym(6)))
TP(Sym(8),NumericPlus(Sym(7),Const(2)))
TP(Sym(9),SimpleLoop(Sym(5),Sym(6),ArrayElem(Block(Sym(8)))))
TP(Sym(10),ArrayIndex(Sym(9),Const(0)))
TP(Sym(11),Reflect(Print(Sym(10)),Summary(true,true,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(12),Reify(Sym(11),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(11))))

-- before transformation
var x4 = new ArrayBuilder[Int]
for (x1 <- 0 until 10) {
val x2 = 1 + x1
val x3 = x2 > 5
if (x3) x4 += x2
}
val x5 = x4.length
var x9 = new Array[Int](x5)
for (x6 <- 0 until x5) {
val x7 = x4.apply(x6)
val x8 = x7 + 2
x9(x6) = x8
}
val x10 = x9.apply(0)
val x11 = println(x10)

-- vertical transformation

(VFT) No producers found for TP(Sym(4),SimpleLoop(Const(10),Sym(1),ArrayIfElem(Sym(3),Block(Sym(2)))))

(VFT) Fusing consumer TP(Sym(9),SimpleLoop(Sym(5),Sym(6),ArrayElem(Block(Sym(8))))) with real producer: Sym(4)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(2).
(VFT) SimpleCollectIf+SimpleCollect fusion: use producer loop with consumer body.

(VFT) all vertically fused: List(Sym(14), Sym(4))

-- after vertical transformation
var x14 = new ArrayBuilder[Int]
for (x1 <- 0 until 10) {
val x2 = 1 + x1
val x3 = x2 > 5
val x13 = x2 + 2
if (x3) x14 += x13
}
val x15 = x14.apply(0)
val x16 = println(x15)

-- horizontal transformation
(HFT) Recording Sym(14), no fusion

(HFT) all horizontally fused: 

-- after horizontal transformation
var x14 = new ArrayBuilder[Int]
for (x1 <- 0 until 10) {
val x2 = 1 + x1
val x3 = x2 > 5
val x13 = x2 + 2
if (x3) x14 += x13
}
val x15 = x14.apply(0)
val x16 = println(x15)

-- fusion
var x14 = new ArrayBuilder[Int]
for (x1 <- 0 until 10) {
val x2 = 1 + x1
val x3 = x2 > 5
val x13 = x2 + 2
if (x3) x14 += x13
}
val x15 = x14.apply(0)
val x16 = println(x15)
-- done
