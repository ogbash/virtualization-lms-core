-- full graph
TP(Sym(3),OrderingGT(Sym(2),Const(5)))
TP(Sym(4),NumericPlus(Sym(2),Const(1)))
TP(Sym(5),SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(3),Block(Sym(4)))))
TP(Sym(6),SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(5)))))
TP(Sym(7),ArrayLength(Sym(6)))
TP(Sym(9),ArrayIndex(Sym(6),Sym(8)))
TP(Sym(10),NumericPlus(Sym(9),Const(2)))
TP(Sym(11),SimpleLoop(Sym(7),Sym(8),ArrayElem(Block(Sym(10)))))
TP(Sym(13),ArrayIndex(Sym(6),Sym(12)))
TP(Sym(14),OrderingGT(Sym(13),Const(20)))
TP(Sym(15),NumericPlus(Sym(13),Const(3)))
TP(Sym(16),SimpleLoop(Sym(7),Sym(12),ArrayIfElem(Sym(14),Block(Sym(15)))))
TP(Sym(18),ArrayIndex(Sym(6),Sym(17)))
TP(Sym(20),NumericPlus(Sym(18),Sym(19)))
TP(Sym(21),SimpleLoop(Sym(18),Sym(19),ArrayElem(Block(Sym(20)))))
TP(Sym(22),SimpleLoop(Sym(7),Sym(17),FlattenElem(Block(Sym(21)))))
TP(Sym(24),ArrayIndex(Sym(6),Sym(23)))
TP(Sym(25),IntDoubleValue(Sym(24)))
TP(Sym(26),NumericPlus(Const(2.0),Sym(25)))
TP(Sym(27),SimpleLoop(Sym(7),Sym(23),ReduceElem(Block(Sym(26)))))
TP(Sym(28),ArrayIndex(Sym(11),Const(0)))
TP(Sym(29),Reflect(Print(Sym(28)),Summary(true,true,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(30),ArrayIndex(Sym(16),Const(0)))
TP(Sym(31),Reflect(Print(Sym(30)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(29))))
TP(Sym(32),ArrayIndex(Sym(22),Const(0)))
TP(Sym(33),Reflect(Print(Sym(32)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(29), Sym(31))))
TP(Sym(34),Reflect(Print(Sym(27)),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(29), Sym(31), Sym(33))))
TP(Sym(35),Reify(Sym(34),Summary(true,true,false,false,false,List(),List(),List(),List()),List(Sym(29), Sym(31), Sym(33), Sym(34))))

-- before transformation
var x5 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
if (x3) x5 += x4
}
var x6 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x6 ++= x5
}
val x7 = x6.length
var x11 = new Array[Int](x7)
for (x8 <- 0 until x7) {
val x9 = x6.apply(x8)
val x10 = x9 + 2
x11(x8) = x10
}
val x28 = x11.apply(0)
val x29 = println(x28)
var x16 = new ArrayBuilder[Int]
for (x12 <- 0 until x7) {
val x13 = x6.apply(x12)
val x14 = x13 > 20
val x15 = x13 + 3
if (x14) x16 += x15
}
val x30 = x16.apply(0)
val x31 = println(x30)
var x22 = new ArrayBuilder[Int]
for (x17 <- 0 until x7) {
val x18 = x6.apply(x17)
var x21 = new Array[Int](x18)
for (x19 <- 0 until x18) {
val x20 = x18 + x19
x21(x19) = x20
}
x22 ++= x21
}
val x32 = x22.apply(0)
val x33 = println(x32)
var x27 = 0
for (x23 <- 0 until x7) {
val x24 = x6.apply(x23)
val x25 = x24.doubleValue()
val x26 = 2.0 + x25
x27 += x26
}
val x34 = println(x27)

-- vertical transformation

(VFT) No producers found for TP(Sym(5),SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(3),Block(Sym(4)))))

(VFT) No producers found for TP(Sym(6),SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(5)))))

(VFT) Fusing consumer TP(Sym(11),SimpleLoop(Sym(7),Sym(8),ArrayElem(Block(Sym(10))))) with real producer: Sym(6)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(5).
(VFT) MultiCollect+Any fusion: fuse consumer with inner array of producer.
(VFT) General fusion: remap index to Sym(2), SimpleIndex to Sym(4).
(VFT) SimpleCollectIf+SimpleCollect fusion: use producer loop with consumer body.

(VFT) Fusing consumer TP(Sym(16),SimpleLoop(Sym(7),Sym(12),ArrayIfElem(Sym(14),Block(Sym(15))))) with real producer: Sym(6)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(5).
(VFT) MultiCollect+Any fusion: fuse consumer with inner array of producer.
(VFT) General fusion: remap index to Sym(2), SimpleIndex to Sym(4).
(VFT) SimpleCollectIf+SimpleCollectIf fusion: add producer conditions to consumer loop.

(VFT) Fusing consumer TP(Sym(22),SimpleLoop(Sym(7),Sym(17),FlattenElem(Block(Sym(21))))) with real producer: Sym(6)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(5).
(VFT) MultiCollect+Any fusion: fuse consumer with inner array of producer.
(VFT) General fusion: remap index to Sym(2), SimpleIndex to Sym(4).
(VFT) SimpleCollectIf+MultiCollect fusion: add if-then-else with empty array to consumer.

(VFT) No producers found for TP(Sym(21),SimpleLoop(Sym(18),Sym(19),ArrayElem(Block(Sym(20)))))

(VFT) Fusing consumer TP(Sym(27),SimpleLoop(Sym(7),Sym(23),ReduceElem(Block(Sym(26))))) with real producer: Sym(6)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(5).
(VFT) MultiCollect+Any fusion: fuse consumer with inner array of producer.
(VFT) General fusion: remap index to Sym(2), SimpleIndex to Sym(4).
(VFT) SimpleCollectIf+Reduce fusion: add if-then-else with neutral element to consumer.

(VFT) all vertically fused: List(Sym(60), Sym(53), Sym(45), Sym(6), Sym(38))
List(Sym(44), Sym(37), Sym(52), Sym(59), Sym(5))

-- after vertical transformation
var x37 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
val x36 = x4 + 2
if (x3) x37 += x36
}
var x38 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x38 ++= x37
}
val x39 = x38.apply(0)
val x40 = println(x39)
var x44 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
val x41 = x4 > 20
val x42 = x41 && x3
val x43 = x4 + 3
if (x42) x44 += x43
}
var x45 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x45 ++= x44
}
val x46 = x45.apply(0)
val x47 = println(x46)
var x48 = new Array[Int](0)
var x52 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x51 = if (x3) {
val x4 = x2 + 1
var x50 = new Array[Int](x4)
for (x19 <- 0 until x4) {
val x49 = x4 + x19
x50(x19) = x49
}
x50
} else {
x48
}
x52 ++= x51
}
var x53 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x53 ++= x52
}
val x54 = x53.apply(0)
val x55 = println(x54)
var x59 = 0
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x58 = if (x3) {
val x4 = x2 + 1
val x56 = x4.doubleValue()
val x57 = 2.0 + x56
x57
} else {
0.0
}
x59 += x58
}
var x60 = 0
for (x1 <- 0 until 30) {
x60 += x59
}
val x61 = println(x60)

-- horizontal transformation
(HFT) Recording Sym(37), no fusion
(HFT) Recording Sym(38), no fusion
(HFT) Fusing Sym(44) with containing fusion set FusedSet(shape = Const(10), indexSym = Sym(2), loopSyms = List(Sym(44), Sym(37), Sym(52), Sym(59), Sym(5)))
(HFT) - already using same index Sym(2)
(HFT) Fusing Sym(45) with containing fusion set FusedSet(shape = Const(30), indexSym = Sym(1), loopSyms = List(Sym(60), Sym(53), Sym(45), Sym(6), Sym(38)))
(HFT) - already using same index Sym(1)
(HFT) Fusing Sym(52) with containing fusion set FusedSet(shape = Const(10), indexSym = Sym(2), loopSyms = List(Sym(44), Sym(37), Sym(52), Sym(59), Sym(5)))
(HFT) - already using same index Sym(2)
(HFT) Recording Sym(50), no fusion
(HFT) Fusing Sym(53) with containing fusion set FusedSet(shape = Const(30), indexSym = Sym(1), loopSyms = List(Sym(60), Sym(53), Sym(45), Sym(6), Sym(38)))
(HFT) - already using same index Sym(1)
(HFT) Fusing Sym(59) with containing fusion set FusedSet(shape = Const(10), indexSym = Sym(2), loopSyms = List(Sym(44), Sym(37), Sym(52), Sym(59), Sym(5)))
(HFT) - already using same index Sym(2)
(HFT) Fusing Sym(60) with containing fusion set FusedSet(shape = Const(30), indexSym = Sym(1), loopSyms = List(Sym(60), Sym(53), Sym(45), Sym(6), Sym(38)))
(HFT) - already using same index Sym(1)

(HFT) all horizontally fused: List(Sym(38), Sym(45), Sym(53), Sym(60))
List(Sym(37), Sym(44), Sym(52), Sym(59))

-- after horizontal transformation
var x37 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
val x36 = x4 + 2
if (x3) x37 += x36
}
var x38 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x38 ++= x37
}
val x39 = x38.apply(0)
val x40 = println(x39)
var x44 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
val x41 = x4 > 20
val x42 = x41 && x3
val x43 = x4 + 3
if (x42) x44 += x43
}
var x45 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x45 ++= x44
}
val x46 = x45.apply(0)
val x47 = println(x46)
var x48 = new Array[Int](0)
var x52 = new ArrayBuilder[Int]
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x51 = if (x3) {
val x4 = x2 + 1
var x50 = new Array[Int](x4)
for (x19 <- 0 until x4) {
val x49 = x4 + x19
x50(x19) = x49
}
x50
} else {
x48
}
x52 ++= x51
}
var x53 = new ArrayBuilder[Int]
for (x1 <- 0 until 30) {
x53 ++= x52
}
val x54 = x53.apply(0)
val x55 = println(x54)
var x59 = 0
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x58 = if (x3) {
val x4 = x2 + 1
val x56 = x4.doubleValue()
val x57 = 2.0 + x56
x57
} else {
0.0
}
x59 += x58
}
var x60 = 0
for (x1 <- 0 until 30) {
x60 += x59
}
val x61 = println(x60)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(38)),List(SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(37))))),SimpleFatLoop(Const(30),Sym(1),List(FlattenElem(Block(Sym(37))))))
TTP(List(Sym(45)),List(SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(44))))),SimpleFatLoop(Const(30),Sym(1),List(FlattenElem(Block(Sym(44))))))
TTP(List(Sym(53)),List(SimpleLoop(Const(30),Sym(1),FlattenElem(Block(Sym(52))))),SimpleFatLoop(Const(30),Sym(1),List(FlattenElem(Block(Sym(52))))))
TTP(List(Sym(60)),List(SimpleLoop(Const(30),Sym(1),ReduceElem(Block(Sym(59))))),SimpleFatLoop(Const(30),Sym(1),List(ReduceElem(Block(Sym(59))))))

(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(37)),List(SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(3),Block(Sym(36))))),SimpleFatLoop(Const(10),Sym(2),List(ArrayIfElem(Sym(3),Block(Sym(36))))))
TTP(List(Sym(44)),List(SimpleLoop(Const(10),Sym(2),ArrayIfElem(Sym(42),Block(Sym(43))))),SimpleFatLoop(Const(10),Sym(2),List(ArrayIfElem(Sym(42),Block(Sym(43))))))
TTP(List(Sym(52)),List(SimpleLoop(Const(10),Sym(2),FlattenElem(Block(Sym(51))))),SimpleFatLoop(Const(10),Sym(2),List(FlattenElem(Block(Sym(51))))))
TTP(List(Sym(59)),List(SimpleLoop(Const(10),Sym(2),ReduceElem(Block(Sym(58))))),SimpleFatLoop(Const(10),Sym(2),List(ReduceElem(Block(Sym(58))))))

var x48 = new Array[Int](0)
var x37 = new ArrayBuilder[Int]
var x44 = new ArrayBuilder[Int]
var x52 = new ArrayBuilder[Int]
var x59 = 0
for (x2 <- 0 until 10) {
val x3 = x2 > 5
val x4 = x2 + 1
val x36 = x4 + 2
val x41 = x4 > 20
val x42 = x41 && x3
val x43 = x4 + 3
val x51 = if (x3) {
var x50 = new Array[Int](x4)
for (x19 <- 0 until x4) {
val x49 = x4 + x19
x50(x19) = x49
}
x50
} else {
x48
}
val x58 = if (x3) {
val x56 = x4.doubleValue()
val x57 = 2.0 + x56
x57
} else {
0.0
}
if (x3) x37 += x36
if (x42) x44 += x43
x52 ++= x51
x59 += x58
}
var x38 = new ArrayBuilder[Int]
var x45 = new ArrayBuilder[Int]
var x53 = new ArrayBuilder[Int]
var x60 = 0
for (x1 <- 0 until 30) {
x38 ++= x37
x45 ++= x44
x53 ++= x52
x60 += x59
}
val x39 = x38.apply(0)
val x40 = println(x39)
val x46 = x45.apply(0)
val x47 = println(x46)
val x54 = x53.apply(0)
val x55 = println(x54)
val x61 = println(x60)
-- done
